# -*- coding: utf-8 -*-

"""Schema module (currently tied to SQLAlchemy, but the idea would be to define more
abstractly (though that may never really happen)
"""

from __future__ import absolute_import, division, print_function

from sqlalchemy import Table, Column, ForeignKey, UniqueConstraint
from sqlalchemy import Integer, Text, Boolean, Date, Time, Interval
from sqlalchemy.dialects.postgresql import ARRAY, JSONB, TIMESTAMP
from sqlalchemy.schema import CreateColumn
from sqlalchemy.ext.compiler import compiles

from utils import LOV

@compiles(CreateColumn, 'postgresql')
def use_identity(element, compiler, **kw):
    text = compiler.visit_create_column(element, **kw)
    text = text.replace("SERIAL", "INTEGER GENERATED BY DEFAULT AS IDENTITY")
    return text

Entity = LOV(['STATION',
              'PROGRAM',
              'RECORDING',
              'PERSON',
              'PERFORMER',
              'ENSEMBLE',
              'WORK',
              'PLAY',
              'PROGRAM_PLAY',
              'PLAY_SEQ',
              'PLAY_SEQ_MATCH'], 'lower')

def load_schema(meta):
    """This is the definition of the database schema

    :param meta: metadata structure to add schema to
    :return: dict of Table specifications, indexed by name
    """
    return {
        Entity.STATION: Table('station', meta,
            Column('id',              Integer,     primary_key=True),
            Column('name',            Text,        nullable=False),
            Column('timezone',        Text,        nullable=False),  # POSIX format (e.g. PST8PDT)
            Column('location',        Text),                         # e.g. "<city>, <state>"
            Column('frequency',       Text)                          # informational only
        ),
        Entity.PROGRAM: Table('program', meta,
            Column('id',              Integer,     primary_key=True),
            Column('name',            Text,        nullable=False),
            Column('host_name',       Text),
            Column('is_syndicated',   Boolean),
            Column('station_id',      Integer,     ForeignKey('station.id')),

            # canonicality
            Column('is_canonical',    Boolean),    # true if syndication master
            Column('cnl_program_id',  Integer,     ForeignKey('program.id')),  # points to self, if canonical
            Column('program_uri',     Text)
        ),
        Entity.RECORDING: Table('recording', meta,
            Column('id',              Integer,     primary_key=True),
            Column('name',            Text,        nullable=False),
            Column('label',           Text),
            Column('catalog_no',      Text),
            Column('release_date',    Date),
            Column('archiv_uri',      Text)
        ),
        Entity.PERSON: Table('person', meta,
            Column('id',              Integer,     primary_key=True),
            Column('name',            Text,        nullable=False),  # TBD: normalized or raw?

            # parsed (pieces of full_name)
            Column('prefix',          Text),
            Column('first_name',      Text),
            Column('middle_name',     Text),
            Column('last_name',       Text),
            Column('suffix',          Text),

            # canonicality
            Column('is_canonical',    Boolean),
            Column('cnl_person_id',   Integer,     ForeignKey('person.id')),  # points to self, if canonical
            Column('archiv_uri',      Text)
        ),
        Entity.PERFORMER: Table('performer', meta,
            Column('id',              Integer,     primary_key=True),
            Column('role',            Text,        nullable=False),  # instrument, voice, role, etc.
            Column('person_id',       Integer,     ForeignKey('person.id'), nullable=False),
            Column('cnl_person_id',   Integer,     ForeignKey('person.id')),

            # constraints
            UniqueConstraint('role', 'person_id')
        ),
        Entity.ENSEMBLE: Table('ensemble', meta,
            Column('id',              Integer,     primary_key=True),
            Column('name',            Text,        nullable=False),

            # canonicality
            Column('is_canonical',    Boolean),
            Column('cnl_ensemble_id', Integer,     ForeignKey('ensemble.id')),  # points to self, if canonical
            Column('archiv_uri',      Text)
        ),
        Entity.WORK: Table('work', meta,
            Column('id',              Integer,     primary_key=True),
            Column('name',            Text,        nullable=False),

            # parsed (and normalized!!!)
            Column('work_type',       Text),
            Column('work_key',        Text),
            Column('catalog_no',      Text),       # i.e. op., K., BWV, etc.

            # canonicality
            Column('is_canonical',    Boolean),
            Column('cnl_work_id',     Integer,     ForeignKey('work.id')),  # points to self, if canonical
            Column('archiv_uri',      Text)
        ),
        Entity.PLAY: Table('play', meta,
            Column('id',              Integer,          primary_key=True),
            Column('station',         Text,             nullable=False),
            Column('play_info',       JSONB,            nullable=False),  # nornalized information
            Column('play_date',       Date,             nullable=False),  # listed local date
            Column('play_start',      Time,             nullable=False),  # listed local time
            Column('play_end',        Time),            # if listed
            Column('play_dur',        Interval),        # if listed

            # foreign keys
            Column('station_id',      Integer,          ForeignKey('station.id')),
            Column('program_id',      Integer,          ForeignKey('program.id')),
            Column('composer_id',     Integer,          ForeignKey('person.id')),
            Column('work_id',         Integer,          ForeignKey('work.id')),
            # note: typically, there will be either artist(s) OR ensemble(s)
            # (though there can also be both) conductors and soloists are
            # associated with ensembles
            Column('artist_ids',      ARRAY(Integer)),  # ForeignKey('performer.id')
            Column('ensemble_ids',    ARRAY(Integer)),  # ForeignKey('ensemble.id')
            Column('conductor_id',    Integer,          ForeignKey('person.id')),
            Column('soloist_ids',     ARRAY(Integer)),  # ForeignKey('performer.id')
            Column('recording_id',    Integer,          ForeignKey('recording.id')),

            # miscellaneous
            Column('notes',           ARRAY(Text)),

            # technical
            Column('start_time',      TIMESTAMP(timezone=True)),
            Column('end_time',        TIMESTAMP(timezone=True)),
            Column('duration',        Interval)
        )
    }
