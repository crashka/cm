#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Database module
"""

from __future__ import absolute_import, division, print_function

from sqlalchemy import create_engine, MetaData
from sqlalchemy import Table, Column, ForeignKey, UniqueConstraint
from sqlalchemy import Integer, Text, Boolean, Date, Time, Interval
from sqlalchemy.dialects.postgresql import ARRAY, JSONB, TIMESTAMP
from sqlalchemy.schema import CreateColumn
from sqlalchemy.ext.compiler import compiles

@compiles(CreateColumn, 'postgresql')
def use_identity(element, compiler, **kw):
    text = compiler.visit_create_column(element, **kw)
    text = text.replace("SERIAL", "INTEGER GENERATED BY DEFAULT AS IDENTITY")
    return text

eng  = create_engine("postgres://crash@/cmdev", echo=True)
meta = MetaData(eng, reflect=True)

if len(meta.tables) == 0:
    Table('station', meta,
        Column('id',              Integer,     primary_key=True),
        Column('name',            Text,        nullable=False),
        Column('timezone',        Text,        nullable=False),  # POSIX format (e.g. PST8PDT)
        Column('location',        Text),                         # e.g. "<city>, <state>"
        Column('frequency',       Text)                          # informational only
    );

    Table('program', meta,
        Column('id',              Integer,     primary_key=True),
        Column('name',            Text,        nullable=False),
        Column('host_name',       Text),
        Column('is_syndicated',   Boolean),
        Column('station_id',      Integer,     ForeignKey('station.id')),

        # canonicality
        Column('is_canonical',    Boolean),    # true if syndication master
        Column('cnl_program_id',  Integer,     ForeignKey('program.id')),  # points to self, if canonical
        Column('program_uri',     Text)
    );

    Table('recording', meta,
        Column('id',              Integer,     primary_key=True),
        Column('name',            Text,        nullable=False),
        Column('label',           Text),
        Column('catalog_no',      Text),
        Column('release_date',    Date),
        Column('archiv_uri',      Text)
    );

    Table('person', meta,
        Column('id',              Integer,     primary_key=True),
        Column('name',            Text,        nullable=False),  # TBD: normalized or raw?

        # parsed (pieces of full_name)
        Column('prefix',          Text),
        Column('first_name',      Text),
        Column('middle_name',     Text),
        Column('last_name',       Text),
        Column('suffix',          Text),

        # canonicality
        Column('is_canonical',    Boolean),
        Column('cnl_person_id',   Integer,     ForeignKey('person.id')),  # points to self, if canonical
        Column('archiv_uri',      Text)
    );

    Table('performer', meta,
        Column('id',              Integer,     primary_key=True),
        Column('role',            Text,        nullable=False),  # instrument, voice, role, etc.
        Column('person_id',       Integer,     ForeignKey('person.id'), nullable=False),
        Column('cnl_person_id',   Integer,     ForeignKey('person.id')),

        # constraints
        UniqueConstraint('role', 'person_id')
    );

    Table('ensemble', meta,
        Column('id',              Integer,     primary_key=True),
        Column('name',            Text,        nullable=False),

        # canonicality
        Column('is_canonical',    Boolean),
        Column('cnl_ensemble_id', Integer,     ForeignKey('ensemble.id')),  # points to self, if canonical
        Column('archiv_uri',      Text)
    );

    Table('piece', meta,
        Column('id',              Integer,     primary_key=True),
        Column('name',            Text,        nullable=False),

        # parsed (and normalized!!!)
        Column('piece_type',      Text),
        Column('piece_key',       Text),
        Column('catalog_no',      Text),       # i.e. op., K., BWV, etc.

        # canonicality
        Column('is_canonical',    Boolean),
        Column('cnl_piece_id',    Integer,     ForeignKey('piece.id')),  # points to self, if canonical
        Column('archiv_uri',      Text)
    );

    Table('play', meta,
        Column('id',              Integer,          primary_key=True),
        Column('station',         Text,             nullable=False),
        Column('play_info',       JSONB,            nullable=False),  # nornalized information
        Column('play_date',       Date,             nullable=False),  # listed local date
        Column('play_start',      Time,             nullable=False),  # listed local time
        Column('play_end',        Time),            # if listed
        Column('play_dur',        Interval),        # if listed

        # foreign keys
        Column('station_id',      Integer,          ForeignKey('station.id')),
        Column('program_id',      Integer,          ForeignKey('program.id')),
        Column('composer_id',     Integer,          ForeignKey('person.id')),
        Column('piece_id',        Integer,          ForeignKey('piece.id')),
        # note: typically, there will be either artist(s) OR ensemble(s)
        # (though there can also be both); conductors and soloists are
        # associated with ensembles
        Column('artist_ids',      ARRAY(Integer)),  # ForeignKey('performer.id')
        Column('ensemble_ids',    ARRAY(Integer)),  # ForeignKey('ensemble.id')
        Column('conductor_id',    Integer,          ForeignKey('person.id')),
        Column('soloist_ids',     ARRAY(Integer)),  # ForeignKey('performer.id')
        Column('recording_id',    Integer,          ForeignKey('recording.id')),

        # miscellaneous
        Column('notes',           ARRAY(Text)),

        # technical
        Column('start_time',      TIMESTAMP(timezone=True)),
        Column('end_time',        TIMESTAMP(timezone=True)),
        Column('duration',        Interval)
    );

    meta.create_all()
