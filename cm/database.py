#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Database module
"""

import logging

from sqlalchemy import create_engine, MetaData
from sqlalchemy import DateTime
from sqlalchemy.schema import CreateColumn
from sqlalchemy.sql import expression
from sqlalchemy.ext.compiler import compiles

from .utils import truthy
from .core import cfg, env, log, dflt_hand, dbg_hand
from . import schema

################
# config stuff #
################

DATABASE = cfg.config('database')

dblog = logging.getLogger('sqlalchemy')
dblog.setLevel(logging.WARN)
dblog.addHandler(dflt_hand)

####################
# PostgreSQL stuff #
####################

# the following is all copied from the SQLAlchemy PostgreSQL dialect page...

class utcnow(expression.FunctionElement):
    type = DateTime()

@compiles(utcnow, 'postgresql')
def pg_utcnow(element, compiler, **kwargs):
    return "TIMEZONE('utc', CURRENT_TIMESTAMP)"

@compiles(CreateColumn, 'postgresql')
def use_identity(element, compiler, **kw):
    text = compiler.visit_create_column(element, **kw)
    text = text.replace("SERIAL", "INTEGER GENERATED BY DEFAULT AS IDENTITY")
    return text

####################
# Database Context #
####################

class DatabaseCtx(object):
    def __init__(self, dbname):
        if dbname not in DATABASE:
            raise RuntimeError("Database name \"%s\" not known" % dbname)
        self.db_info = DATABASE[dbname]
        if truthy(self.db_info.get('sql_tracing')):
            dblog.setLevel(logging.INFO)
        self.eng  = create_engine(self.db_info['connect_str'], echo=True)
        self.conn = self.eng.connect()
        self.meta = MetaData()
        self.meta.reflect(self.eng)

    def create_schema(self, tables = None, dryrun = False, force = False):
        if len(self.meta.tables) > 0:
            raise RuntimeError("Schema must be empty, create is aborted")

        schema.load_schema(self.meta)
        with self.conn.begin():
            if not tables or tables == 'all':
                self.meta.create_all(self.conn)
            else:
                to_create = [self.meta.tables[tab] for tab in tables.split(',')]
                self.meta.create_all(self.conn, tables=to_create)

    def drop_schema(self, tables = None, dryrun = False, force = False):
        if len(self.meta.tables) == 0:
            raise RuntimeError("Schema is empty, nothing to drop")

        with self.conn.begin():
            if not tables or tables == 'all':
                if not force:
                    raise RuntimeError("Force must be specified if no list of tables given")
                self.meta.drop_all(self.conn)
            else:
                to_drop = [self.meta.tables[tab] for tab in tables.split(',')]
                self.meta.drop_all(self.conn, tables=to_drop)

        self.meta.clear()
        self.meta.reflect(self.eng)

    def get_table(self, name):
        return self.meta.tables[name]

#####################
# command line tool #
#####################

import click

@click.command()
@click.option('--list',     'cmd', flag_value='list', default=True, help="List all (or specified) tables for the database")
@click.option('--create',   'cmd', flag_value='create', help="Create specified table(s); NOTE: database must already be created")
@click.option('--drop',     'cmd', flag_value='drop', help="Drop specified table(s); NOTE, does not drop the actual database")
@click.option('--validate', 'cmd', flag_value='validate', help="Validate existing table(s) against current schema definition")
@click.option('--upgrade',  'cmd', flag_value='upgrade', help="Upgrade specified tables to new schema definition")
@click.option('--tables',   help="Table (or comma-separated list of tables) to operate on; defaults to 'all'")
@click.option('--force',    is_flag=True, help="Not currently implemented")
@click.option('--dryrun',   is_flag=True, help="Do not write changes to database, show SQL instead")
@click.option('--debug',    default=0, help="Debug level")
@click.argument('dbname',   required=False)
def main(cmd, tables, force, dryrun, debug, dbname):
    """Manage database schema for specified DBNAME (defined in config file)
    """
    if debug > 0:
        log.setLevel(logging.DEBUG)
        log.addHandler(dbg_hand)
        # NOTE: DEBUG mode enables showing of query results (very verbose)
        #dblog.setLevel(logging.DEBUG)
        dblog.addHandler(dbg_hand)

    db = DatabaseCtx(dbname or env.get('database'))

    if cmd == 'list':
        pass
    elif cmd == 'create':
        db.create_schema(tables, dryrun, force)
    elif cmd == 'drop':
        db.drop_schema(tables, dryrun, force)
    elif cmd == 'validate':
        pass
    elif cmd == 'upgrade':
        pass

if __name__ == '__main__':
    main()
